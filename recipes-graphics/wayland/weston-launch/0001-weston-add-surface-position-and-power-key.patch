#This patch file is from Qualcomm Innovation Center, Inc. and is provided under the following license:
#
#Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
#SPDX-License-Identifier: BSD-3-Clause-Clear
commit c16417a4b94474bac8bde60250476294bf52c164
Author: Rajavenu Kyatham <quic_rkyatham@quicinc.com>
Date:   Thu Nov 21 14:44:50 2024 +0530

    weston: add surface position and power key.

Upstream-Status: Inappropriate [Downstream]
Signed-off-by: Rajavenu Kyatham <quic_rkyatham@quicinc.com>

diff --git a/compositor/main.c b/compositor/main.c
index 4d4e3ec..c1908df 100644
--- a/compositor/main.c
+++ b/compositor/main.c
@@ -26,6 +26,10 @@
  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
  */

 #include "config.h"
@@ -46,6 +50,8 @@
 #include <linux/input.h>
 #include <sys/time.h>
 #include <linux/limits.h>
+#include <syslog.h>
+#include <stdarg.h>

 #include "weston.h"
 #include <libweston/libweston.h>
@@ -71,6 +77,9 @@
 #include <libweston/remoting-plugin.h>
 #include <libweston/pipewire-plugin.h>

+#undef  LOG_TAG
+#define LOG_TAG "weston"
+
 #define WINDOW_TITLE "Weston Compositor"
 /* flight recorder size (in bytes) */
 #define DEFAULT_FLIGHT_REC_SIZE (5 * 1024 * 1024)
@@ -240,6 +249,15 @@ vlog_continue(const char *fmt, va_list argp)
	return weston_log_scope_vprintf(log_scope, fmt, argp);
 }

+/* redirects weston logs to syslog */
+static int
+weston_syslog(const char *fmt, va_list argp)
+{
+	vsyslog(LOG_INFO, fmt, argp);
+
+	return 0;
+}
+
 static const char *
 get_next_argument(const char *signature, char* type)
 {
@@ -4064,6 +4082,18 @@ weston_log_subscribe_to_scopes(struct weston_log_context *log_ctx,
		weston_log_setup_scopes(log_ctx, flight_rec, flight_rec_scopes);
 }

+/* sig_handler funtion prints the PID, UID and fault address and then calls print_backtrace */
+static void sig_handler(int signal_number, siginfo_t *siginfo, void *context)
+{
+        weston_log("caught signal %d\n", signal_number);
+        weston_log("PID: %u UID: %u\n", getpid(), getuid());
+        if(siginfo->si_addr == NULL)
+                weston_log("Fault address: 0x0\n");
+        else
+                weston_log("Fault address: %p\n", siginfo->si_addr);
+        print_backtrace();
+}
+
 static void
 screenshot_allow_all(struct wl_listener *l,
		     struct weston_output_capture_attempt *att)
@@ -4180,7 +4210,11 @@ wet_main(int argc, char *argv[], const struct weston_testsuite_data *test_data)
	if (!weston_log_file_open(log))
		return EXIT_FAILURE;

-	weston_log_set_handler(vlog, vlog_continue);
+	if (log == NULL || strstr(log, "syslog") == NULL) {
+		weston_log_set_handler(vlog, vlog_continue);
+	} else {
+		weston_log_set_handler(weston_syslog, weston_syslog);
+	}

	logger = weston_log_subscriber_create_log(weston_logfile);

diff --git a/libweston/backend-drm/drm.c b/libweston/backend-drm/drm.c
index b46ed63..d2daf54 100644
--- a/libweston/backend-drm/drm.c
+++ b/libweston/backend-drm/drm.c
@@ -850,7 +850,12 @@ drm_output_start_repaint_loop(struct weston_output *output_base)
			millihz_to_nsec(output->base.current_mode->refresh);
		if (timespec_to_nsec(&vbl2now) < refresh_nsec) {
			drm_output_update_msc(output, vbl.reply.sequence);
+#ifdef QCOM_BSP
+			weston_output_finish_frame(output_base, &tnow,
+						WP_PRESENTATION_FEEDBACK_INVALID);
+#else
			weston_output_finish_frame(output_base, &ts, flags);
+#endif
			return 0;
		}
	}
diff --git a/libweston/backend-drm/meson.build b/libweston/backend-drm/meson.build
index e048789..186c4c2 100644
--- a/libweston/backend-drm/meson.build
+++ b/libweston/backend-drm/meson.build
@@ -89,6 +89,10 @@ if get_option('remoting') or get_option('pipewire')
	config_h.set('BUILD_DRM_VIRTUAL', '1')
 endif

+if get_option('qcom-bsp')
+	config_h.set('QCOM_BSP', '1')
+endif
+
 plugin_drm = shared_library(
	'drm-backend',
	srcs_drm,
diff --git a/libweston/input.c b/libweston/input.c
index c72c24b..8e00d4a 100644
--- a/libweston/input.c
+++ b/libweston/input.c
@@ -23,6 +23,11 @@
  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ *
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
  */

 #include "config.h"
@@ -2665,6 +2670,44 @@ notify_key(struct weston_seat *seat, const struct timespec *time, uint32_t key,
	struct weston_keyboard_grab *grab = keyboard->grab;
	uint32_t *k, *end;

+#ifndef DISABLE_POWER_KEY
+	/* When power button is pressed for one time, weston receives two events
+	for key KEY_POWER as below:-
+	1. WL_KEYBOARD_KEY_STATE_RELEASED
+	2. WL_KEYBOARD_KEY_STATE_PRESSED
+	We are acting only on one event WL_KEYBOARD_KEY_STATE_PRESSED, and changing display
+	state. We are ignoring WL_KEYBOARD_KEY_STATE_RELEASED event.
+	*/
+
+	static bool display_on = true;
+	if (state == WL_KEYBOARD_KEY_STATE_PRESSED && key == KEY_POWER && display_on) {
+		weston_compositor_sleep(compositor);
+		display_on = false;
+		weston_log("Display OFF \n");
+		return;
+	} else if (state == WL_KEYBOARD_KEY_STATE_PRESSED && key == KEY_POWER && !display_on) {
+		weston_compositor_wake(compositor);
+		weston_compositor_schedule_repaint(compositor);
+		display_on = true;
+		weston_log("Display ON \n");
+		return;
+	}
+#endif
+
+	if (key == KEY_POWER) {
+		// ignore WL_KEYBOARD_KEY_STATE_RELEASED event.
+		return;
+	}
+
+	if ((key != KEY_VOLUMEDOWN) && (key != KEY_VOLUMEUP) && (key != KEY_BRIGHTNESSDOWN) &&
+		(key != KEY_BRIGHTNESSUP) ) {
+		if (state == WL_KEYBOARD_KEY_STATE_PRESSED) {
+			weston_compositor_idle_inhibit(compositor);
+		} else {
+			weston_compositor_idle_release(compositor);
+		}
+  }
+
	end = keyboard->keys.data + keyboard->keys.size;
	for (k = keyboard->keys.data; k < end; k++) {
		if (*k == key) {
@@ -2680,12 +2723,6 @@ notify_key(struct weston_seat *seat, const struct timespec *time, uint32_t key,
		*k = key;
	}

-	if (state == WL_KEYBOARD_KEY_STATE_PRESSED) {
-		weston_compositor_idle_inhibit(compositor);
-	} else {
-		weston_compositor_idle_release(compositor);
-	}
-
	if (grab == &keyboard->default_grab ||
	    grab == &keyboard->input_method_grab) {
		weston_compositor_run_key_binding(compositor, keyboard, time,
diff --git a/meson_options.txt b/meson_options.txt
index cbb4080..4d383d9 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -1,17 +1,18 @@
 # This option is not implemented:
 #  --with-cairo=[image|gl|glesv2] Which Cairo renderer to use for the clients
 # It is hardcoded to cairo-image for now.
+
 option(
-       'backend-sdm',
-       type: 'boolean',
-       value: true,
-       description: 'Weston backend with MSM SDM compositor'
+	'backend-sdm',
+	type: 'boolean',
+	value: true,
+	description: 'Weston backend with MSM SDM compositor'
 )
 option(
-       'disable-power-key',
-       type: 'boolean',
-       value: false,
-       description: 'Weston backend: disable power key handling'
+	'disable-power-key',
+	type: 'boolean',
+	value: false,
+	description: 'Weston backend: disable power key handling'
 )
 option(
	'backend-drm',
@@ -231,3 +232,9 @@ option(
	value: false,
	description: 'Generate documentation'
 )
+option(
+	'qcom-bsp',
+	type: 'boolean',
+	value: true,
+	description: 'DRM: run qcom bsp related flow'
+)
